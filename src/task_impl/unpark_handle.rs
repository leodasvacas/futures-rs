use core::ptr;
use core::mem::{forget, size_of};
use core::marker::PhantomData;
use super::Unpark;

/// Maxlmum size in bytes that will fit in a UnparkObject.
/// TODO: What should this value be?
/// Should we expose this?
/// We probably want to say that this value may increase but never decrease in a 1.x release.
const MAX_OBJ_BYTES : usize = 64;

/// A VTable that knows how to clone because the data has a maximum size.
#[derive(Copy)]
struct UnparkVtable {
    unpark : fn(*const ()),
    clone_to_byte_buffer : fn(*const ()) -> [u8; MAX_OBJ_BYTES],
    drop_in_place : unsafe fn(*mut ()),
}

impl Clone for UnparkVtable {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}

impl UnparkVtable {
    fn new<T : Unpark + Clone>() -> UnparkVtable {
        assert!(size_of::<T>() <= MAX_OBJ_BYTES);
        UnparkVtable {
           unpark : Self::call_unpark::<T>,
           clone_to_byte_buffer : Self::clone_to_byte_buffer::<T>,
           drop_in_place : Self::drop_in_place::<T>,
       }
    }

    fn call_unpark<T : Unpark>(data : *const ()) {
        let downcasted = unsafe { &*(data as *const _ as *const T) };
        downcasted.unpark()
    }

    /// Returns array with bytes of the cloned data. Make sure data is shorter than MAX_OBJ_BYTES.
    /// The caller owns the new data and is responsible for dropping it with `drop_in_place<T>`.
    fn clone_to_byte_buffer<T : Clone>(data : *const ()) -> [u8; MAX_OBJ_BYTES] {
        let downcasted =  unsafe { &*(data as *const _ as *const T) };
        let cloned = downcasted.clone();
        let mut buffer = [0; MAX_OBJ_BYTES];
        // View cloned and buffer as raw bytes.
        let cloned_ptr = &cloned as *const _ as *const u8;
        let buffer_ptr = &mut buffer as *mut _ as *mut u8;
        // Copy from cloned to the buffer and forget cloned.
        // Semantically, the buffer now owns cloned.
        unsafe { ptr::copy_nonoverlapping(cloned_ptr, buffer_ptr, size_of::<T>()); }
        forget(cloned);
        buffer
    }

    /// Make sure the original value is forgotten to avoid double free.
    unsafe fn drop_in_place<T>(data : *mut ()) {
        ptr::drop_in_place(&mut *(data as *mut _ as *mut T));
    }
}

/// `UnparkHandle` is used as an argument to methods like 'poll_future'.
///  Each `Task` handle generated by `task::park` will contain a fresh clone
///  of the `unpark` argument provided to `UnparkHandle::new`.
///  Depending on your use case, you may want to wrap your `unpark` value in
///  an `Arc` before passing it to the `UnparkHandle`.
///
/// # Deciding whether to use an `Arc`
/// If your `unpark` is not `Clone` or has lifetime parameters then you must use an `Arc`.
/// If you use inner mutability in your `unpark`, then you should carefully
/// consider what happens when it is cloned and what is the behaviour you want.
/// Inner mutability aside, the only difference between using or not an `Arc` should be performance.
/// An `Arc` will cost an allocation upfront and updates an atomic ref count on park,
/// while no `Arc` has no upfront cost but will cost a clone on park.
/// The best strategy depends on how often your futures park and how costly it is to clone `unpark`.
#[derive(Copy, Clone)] // Safe to copy because `UnparkHandle` never mutates itself.
#[allow(missing_debug_implementations)]
pub struct UnparkHandle<'a> {
    // Trait object that can clone `data` into an 'UnparkObj` to be put in a `Task`.
    data : *const (),
    data_lifetime : PhantomData<&'a ()>,
    vtable : UnparkVtable,
}

impl<'a> UnparkHandle<'a> {
    /// Constructs a `UnparkHandle`.
    /// A `Task` handle returned by `park` will contain a clone of the `unpark`
    /// argument provided here. You may want to wrap `unpark` in an `Arc`.
    ///
    /// # Panic
    /// Panics if the size of 'T' is too large. If you get a panic try wrapping the argument
    /// in an `Arc`.

    // Take unpark as &mut data to make sure it dosen't change under our feet due to inner mutability.
    // T must be static so we don't clone around references to a stack or something.
    pub fn new<T : Unpark + Clone + 'static>(unpark : &mut T) -> UnparkHandle<'a> {
        if size_of::<T>() > MAX_OBJ_BYTES {
            // TODO: Panicking here seems reasonable and could be a compile time error when we
            // get a const sytem in Rust. But what about libraries that pass a user supplied type as T?
            // Should we expose MAX_OBJ_BYTES? Offer a version that return an error?
            panic!("The size of T is {} bytes which is too large. Try wrapping the unpark argument in an Arc.");
        }

        UnparkHandle {
            data : unpark as *const _ as *const (),
            data_lifetime : PhantomData,
            vtable : UnparkVtable::new::<T>(),
        }
    }
}

/// A custom trait object that takes ownership of the data as a slice of bytes.
pub struct UnparkObj {
    data : [u8; MAX_OBJ_BYTES],
    vtable : UnparkVtable,
}

impl Drop for UnparkObj {
    fn drop(&mut self) {
        unsafe { (self.vtable.drop_in_place)(&mut self.data as *mut _ as *mut ()); }
    }
}

impl UnparkObj {
    fn new(data : *const (), vtable : UnparkVtable) -> Self {
        UnparkObj {
            data : (vtable.clone_to_byte_buffer)(data),
            vtable : vtable,
        }
    }
}

impl Clone for UnparkObj {
    fn clone(&self) -> Self {
        UnparkObj::new(&self.data as *const _ as *const (), self.vtable)
    }
}

impl<'a> From<UnparkHandle<'a>> for UnparkObj {
    fn from(handle : UnparkHandle) -> UnparkObj {
        UnparkObj::new(handle.data, handle.vtable)
    }
}

impl Unpark for UnparkObj {
    fn unpark(&self) {
        (self.vtable.unpark)(&self.data as *const _ as *const ())
    }
}
